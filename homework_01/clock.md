# 神奇的电子表

台风过后，助教突然发现宿舍里多出了一块电子表，在送交电子表的路上，
助教发现这块电子表的时间和北京时间对不上，于是他打算修好这块表。经过几天的观察，助教发现每过1h的时间，表的时间就会比北京时间滞后1分钟，即北京每经过1h,表时间经过59min。北京时间2024-09-16T00:00:00时，电子表显示的时间为2024-09-01T22:20:00。需要你完成一个程序，输入电子表当前的时间，输出真实的北京时间，**结果精确到秒(向下取整)**，即忽略毫秒。  

  

**注意**  
1.日期，时间的起始不一样，是0/1？  ***起始边界***  
2.取整条件的考虑：最后取整时，注意正数和负数对取整的影响，要保证都向下，整数除法默认向零取整，因此要自己写函数！
```c++
long long floor_div(long long a, long long b) {
    // b > 0
    if (a >= 0) return a / b;
    return - ((-a + b - 1) / b);  // 等价于 floor(a/b)
}
```
3.数据类型的选择很重要，需要大整数时，虽然double数据范围更大，但大数精度不够好，要使用long long  
4.灵活运用已经造好的轮子，用已知数构造未知数
```c++
 res+=countrest(year,month,day,hour,min,sec)-countrest(year,9,1,22,20,0);
```
5.if-else 逻辑大括号不要乱省  
6.对于计数器类型的变量不要随意修改，以后是否再用？先修改还是先引用？
```c++
 //first 先减去当月的，否则月份变了！
                secRest-=ptr[month];
                if(month==12) {
                    year++;
                    month=1;
                }else {
                    month++;
                }
```
7.对于已知的数据使用常数组，便于使用
```c++
int secofMonth1[13]={0,31*24*60*60,28*24*60*60,31*24*60*60,30*24*60*60,31*24*60*60,
    30*24*60*60,31*24*60*60,31*24*60*60,30*24*60*60,31*24*60*60,30*24*60*60,31*24*60*60,};
 int secofMonth2[13]={0,31*24*60*60,29*24*60*60,31*24*60*60,30*24*60*60,31*24*60*60,
    30*24*60*60,31*24*60*60,31*24*60*60,30*24*60*60,31*24*60*60,30*24*60*60,31*24*60*60,};

```
//TODO